use bellman_ce::groth16::Proof as BellmanProof;
use bellman_ce::pairing::{
    bn256::{Bn256, G1Affine, G2Affine},
    CurveAffine,
};
use base64::{decode, encode};

/// The relation to be proved.
#[derive(PartialEq, Debug)]
pub enum Relation {
    Younger,
    Older,
}

/// Public part of the proof.
#[derive(Debug)]
pub struct Public {
    /// Today julian date.
    pub today: u32,

    /// Current UTC time since midnight. Publicly encoded in the QR code but not used
    /// in the proof.
    pub now: u32,

    /// Relation.
    pub relation: Relation,

    /// Minimal (maximal) difference between 'today' and 'birthday' in days.
    pub delta: u32,
}

impl Public {
    pub fn new() -> Self {
        Public {
            today: 0,
            now: 0,
            relation: Relation::Younger,
            delta: 0,
        }
    }
}

/// Request for QR code generation from phone app.
#[derive(Debug)]
pub struct QrRequest {
    /// Public part of the proof.
    pub public: Public,

    /// Birthday - julian date. Private part of the proof.
    pub birthday: u32,

    /// Private key known only to the prover and to the
    /// certifier. Big-endian encoded number in Field range. Private
    /// part of the proof.
    pub private_key: Vec<u8>,

    /// Digest of the photoset. Big-endian encoded number in Field
    /// range. Private part of the proof.
    pub photos_digest: Vec<u8>,
}

impl QrRequest {
    pub fn new() -> Self {
        QrRequest {
            public: Public::new(),
            birthday: 0,
            private_key: Vec::new(),
            photos_digest: Vec::new(),
        }
    }

    pub fn to_qr_code_string() -> String {
        String::from("")
    }

    pub fn from_qr_code_string(qr_str: &str) -> Self {
        QrRequest::new()
    }
}

/// QR code containing the proof. Is generated by the proved and verified by the
/// verifier
#[derive(Debug)]
pub struct ProofQrCode {
    /// Public part of the proof.
    pub public: Public,

    // Proof a,b,c curve points.
    pub proof: BellmanProof<Bn256>,

    /// Challenge. Big-endian encoded number in Field
    /// range. Public output of the proof computation.
    pub challenge: Vec<u8>,
}

// impl FromStr for ProofQr {
//     type Err = ParseIntError;

//     fn from_str(s: &str) -> Result<Self, Self::Err> {
//         Ok(Poin { x: x_fromstr, y: y_fromstr })
//     }

// }

// impl ProofQrCode {
//     pub fn new() -> Self {
//         ProofQrCode {
//             public: Public::new(),
//             a: G1Affine::zero(),
// 	    b: G2Affine::zero(),
// 	    c: G1Affine::zero(),
//             challenge: Vec::new(),
//         }
//     }
// }
